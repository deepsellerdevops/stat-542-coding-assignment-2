---
title: "Stat 542 Coding Assignment 2"
author: "Doug Mulley"
date: "9/18/2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(glmnet)
library(Matrix)
library(foreach)

rm(list = ls())
set.seed(9764)
```

## Part 1: BostonHousing1.data

```{r include=FALSE}
load('BostonHousing1.Rdata')
myData = Housing1

n = nrow(myData)
p = ncol(myData) - 1

X = data.matrix(myData[,-1])
Y = myData[,1]

T = 50
```

```{r include=FALSE}
ntest = round(n * 0.25)
ntrain = n - ntest

all.test.id = matrix(0, nrow = ntest, ncol = T)

for (t in 1:T) {
  all.test.id[,t] = sample(1:n, ntest)
}

model_names = c("Full", 
                "AIC.F", "AIC.B", 
                "BIC.F", "BIC.B", 
                "R.min", "R.1se", 
                "L.min", "L.1se",
                "L.Refit")

nmodels = length(model_names)

metrics = data.frame(rep(model_names, each = T), numeric(nmodels * T), numeric(nmodels * T), numeric(nmodels * T))
colnames(metrics) = c("model", "mspe", "time", "modelSize")

calculateRowIndex <- function (model_index, t) {
  ((model_index - 1) * T) + t
}

calculateMSPE <- function (test.id, predictedY) {
  mean((Y[test.id] - predictedY) ^ 2)
}

model.index = 1

for (t in 1:T) {
  time.start = proc.time()
  test.id = all.test.id[,t]
  full.model = lm(Y ~ ., data = myData[-test.id,])
  Ytest.pred = predict(full.model, newdata = myData[test.id,])
  time.span = proc.time() - time.start
  mse = calculateMSPE(test.id, Ytest.pred)
  metrics[calculateRowIndex(model.index, t), 2:4] = c(mse, time.span["elapsed"], dim(X)[2] - 1)
}

model.index = 2

for (t in 1:T) {
  time.start = proc.time()
  test.id = all.test.id[, t]
  full.model = lm(Y ~ ., data = myData[-test.id, ])
  stepAIC = step(lm(Y ~ 1, data = myData[-test.id, ]),
                 list(upper = full.model),
                 trace = 0,
                 direction = "forward")
  Ytest.pred = predict(stepAIC, newdata = myData[test.id, ])
  time.span = proc.time() - time.start
  mse = calculateMSPE(test.id, Ytest.pred)
  metrics[calculateRowIndex(model.index, t), 2:4] = c(mse, time.span["elapsed"], length(stepAIC$coef) - 1)
}

model.index = 3

for (t in 1:T) {
  time.start = proc.time()
  test.id = all.test.id[, t]
  full.model = lm(Y ~ ., data = myData[-test.id, ])
  stepAIC = step(full.model,
                 trace = 0,
                 direction = "backward")
  Ytest.pred = predict(stepAIC, newdata = myData[test.id, ])
  time.span = proc.time() - time.start
  mse = calculateMSPE(test.id, Ytest.pred)
  metrics[calculateRowIndex(model.index, t), 2:4] = c(mse, time.span["elapsed"], length(stepAIC$coef) - 1)
}

model.index = 4

for (t in 1:T) {
  time.start = proc.time()
  test.id = all.test.id[, t]
  full.model = lm(Y ~ ., data = myData[-test.id, ])
  stepAIC = step(lm(Y ~ 1, data = myData[-test.id, ]),
                 list(upper = full.model),
                 trace = 0, direction = "forward", k = log(ntrain))
  Ytest.pred = predict(stepAIC, newdata = myData[test.id, ])
  time.span = proc.time() - time.start
  mse = calculateMSPE(test.id, Ytest.pred)
  metrics[calculateRowIndex(model.index, t), 2:4] = c(mse, time.span["elapsed"], length(stepAIC$coef) - 1)
}

model.index = 5

for (t in 1:T) {
  time.start = proc.time()
  test.id = all.test.id[, t]
  full.model = lm(Y ~ ., data = myData[-test.id, ])
  stepAIC = step(full.model, 
                 trace = 0,
                 direction = "backward", 
                 k = log(ntrain))
  Ytest.pred = predict(stepAIC, newdata = myData[test.id, ])
  time.span = proc.time() - time.start
  mse = calculateMSPE(test.id, Ytest.pred)
  metrics[calculateRowIndex(model.index, t), 2:4] = c(mse, time.span["elapsed"], length(stepAIC$coef) - 1)
}

model.index = 6

for (t in 1:T) {
  time.start = proc.time()
  test.id = all.test.id[, t]
  cv.out = cv.glmnet(X[-test.id, ], Y[-test.id], alpha = 0)
  best.lam = cv.out$lambda.min
  Ytest.pred = predict(cv.out, 
                       s = best.lam, 
                       newx = X[test.id, ])
  time.span = proc.time() - time.start
  mse = calculateMSPE(test.id, Ytest.pred)
  
  ntrain = n - dim(all.test.id)[1]
  tmpX = scale(X[-test.id, ]) * sqrt(ntrain / (ntrain - 1))
  d = svd(tmpX)$d
  df = sum(d^2/(d^2 + best.lam*ntrain))
  
  metrics[calculateRowIndex(model.index, t), 2:4] = c(mse, time.span["elapsed"], df)
}

model.index = 7

for (t in 1:T) {
  time.start = proc.time()
  test.id = all.test.id[, t]
  cv.out = cv.glmnet(X[-test.id, ], Y[-test.id], alpha = 0)
  best.lam = cv.out$lambda.1se
  Ytest.pred = predict(cv.out, 
                       s = best.lam, 
                       newx = X[test.id, ])
  time.span = proc.time() - time.start
  mse = calculateMSPE(test.id, Ytest.pred)
  
  ntrain = n - dim(all.test.id)[1]
  tmpX = scale(X[-test.id, ]) * sqrt(ntrain / (ntrain - 1))
  d = svd(tmpX)$d
  df = sum(d^2/(d^2 + best.lam*ntrain))
  
  metrics[calculateRowIndex(model.index, t), 2:4] = c(mse, time.span["elapsed"], df)
}

model.index = 8

for (t in 1:T) {
  time.start = proc.time()
  test.id = all.test.id[, t]
  cv.out = cv.glmnet(X[-test.id, ], Y[-test.id], alpha = 1)
  best.lam = cv.out$lambda.min
  Ytest.pred = predict(cv.out, 
                       s = best.lam, 
                       newx = X[test.id, ])
  mse = calculateMSPE(test.id, Ytest.pred)
  time.span = proc.time() - time.start
  
  mylasso.coef = predict(cv.out, s = best.lam, type = "coefficients")
  sum(mylasso.coef != 0) - 1
  
  metrics[calculateRowIndex(model.index, t), 2:4] = c(mse, time.span["elapsed"], sum(mylasso.coef != 0) - 1)
}

model.index = 9

for (t in 1:T) {
  time.start = proc.time()
  test.id = all.test.id[, t]
  cv.out = cv.glmnet(X[-test.id, ], Y[-test.id], alpha = 1)
  best.lam = cv.out$lambda.1se
  Ytest.pred = predict(cv.out, 
                       s = best.lam, 
                       newx = X[test.id, ])
  
  time.span = proc.time() - time.start
  mse = calculateMSPE(test.id, Ytest.pred)
  mylasso.coef = predict(cv.out, s = best.lam, type = "coefficients")
  metrics[calculateRowIndex(model.index, t), 2:4] = c(mse, time.span["elapsed"], sum(mylasso.coef != 0) - 1)
}

model.index = 10

for (t in 1:T) {
  time.start = proc.time()
  test.id = all.test.id[, t]
  cv.out = cv.glmnet(X[-test.id, ], Y[-test.id], alpha = 1)
  best.lam = cv.out$lambda.1se
  Ytest.pred = predict(cv.out, s = best.lam, newx = X[test.id, ])
  mylasso.coef = predict(cv.out, 
                         s = best.lam, 
                         type = "coefficients")
  modelSize = sum(mylasso.coef != 0) - 1
  
  var.sel = row.names(mylasso.coef)[nonzeroCoef(mylasso.coef)[-1]]
  tmp.X = X[, colnames(X) %in% var.sel]
  mylasso.refit = coef(lm(Y[-test.id] ~ tmp.X[-test.id, ]))
  Ytest.pred = mylasso.refit[1] + tmp.X[test.id,] %*% mylasso.refit[-1]
  time.span = proc.time() - time.start
  mse = calculateMSPE(test.id, Ytest.pred)
  
  metrics[calculateRowIndex(model.index, t), 2:4] = c(mse, time.span["elapsed"], modelSize)
}
```

```{r echo=FALSE}
boxplot(mspe ~ model, 
        data = metrics,
        main = "Boston housing 1 - Prediction error by method",
        xlab = "Method", 
        las = 2,
        ylab = "Prediction error")

boxplot(modelSize ~ model,
        data = metrics,
        main = "Boston housing 1 - Model size by method",
        xlab = "Method",
        las = 2,
        ylab = "Model size")
```